#!/usr/bin/env python3
import re
from typing import Generator, Iterable, NamedTuple

from bs4 import BeautifulSoup
import requests
import os


class Relator(NamedTuple):
    code: str
    term: str
    description: str


def get_soup() -> BeautifulSoup:
    file_name = "relaterm.html"
    url = "https://www.loc.gov/marc/relators/relaterm.html"

    if os.path.isfile(file_name):
        print(f"Already downloaded {url} as {file_name}.")
    else:
        print(f"Downloading {url} as {file_name} …")
        page = requests.get(url)
        with open(file_name, 'wb') as f:
            f.write(page.content)

    print("Parsing …")
    with open(file_name, 'r') as f:
        soup = BeautifulSoup(f, 'html.parser')

    return soup


def get_terms(soup: BeautifulSoup) -> Generator[Relator, None, None]:
    # The last definition list on the page is the one we want.
    definition_list = soup.find_all('dl')[-1]
    for term_soup in definition_list.find_all('dt'):
        try:
            yield Relator(
                code=term_soup.find(class_='relator-code').text.strip(" []"),
                term=term_soup.find(class_='authorized').text.strip(),
                description=term_soup.find_next_sibling('dd').text.strip(),
            )
        except AttributeError:
            # Just skip the invalid ones.
            pass


def writePhpClass(terms: Iterable[Relator]) -> str:
    php_constants = []
    php_descriptions = []
    php_terms = []
    php_codes = []

    non_az = re.compile(r"[^A-Z]+")
    whitespace = re.compile(r"\s+")

    for t in terms:
        const_name = non_az.sub('_', t.term.upper()).strip('_')
        php_constants.append(f"  const {const_name} = '{t.code}';")
        description = whitespace.sub(' ', t.description.translate(str.maketrans({
            r"'": r"\'",
        })))
        php_descriptions.append(f"    self::{const_name} => '{description}',")
        php_terms.append(f"    self::{const_name} => '{t.term}',")
        php_codes.append(f"    '{t.term.casefold()}' => self::{const_name},")

    php_constants = "\n".join(php_constants)
    php_descriptions = "\n".join(php_descriptions)
    php_terms = "\n".join(php_terms)
    php_codes = "\n".join(php_codes)

    file_name = os.path.basename(__file__)

    return rf"""<?php

namespace RudolfByker\PhpMarcCsl;

/**
 * Class Relators.
 *
 * Valid options for subfields $e and $4 in fields X00.
 * See https://www.loc.gov/marc/bibliographic/bdx00.html
 * and https://www.loc.gov/marc/relators/relaterm.html
 * and https://www.loc.gov/marc/relators/relacode.html .
 *
 * $e refers to the "relator term", e.g. "author" (sometimes containing trailing
 * punctuation) and is mostly meant to be human-readable. $4 refers to the
 * "relator code" or "relationship" and is a 3-letter code. $4 is better suited
 * than $e as a machine-readable code.
 *
 * This file is auto-generated by '{file_name}'.
 * Don't edit it directly.
 */
abstract class Relators {{

{php_constants}

  /**
   * Relator descriptions, keyed by relator code.
   *
   * @var string[]
   */
  public static $descriptions = [
{php_descriptions}
  ];

  /**
   * Relator terms, keyed by relator code.
   *
   * @var string[]
   */
  public static $terms = [
{php_terms}
  ];

  /**
   * Relator codes, keyed by lower-cased relator term.
   *
   * Useful as a reverse lookup when the user provides a term but not a code.
   *
   * @var string[]
   */
  public static $codes = [
{php_codes}
  ];

}}
"""


def main():
    file_name = "../src/Relators.php"
    with open(file_name, 'w') as f:
        print(f"Writing new PHP code to {file_name}")
        f.write(writePhpClass(get_terms(get_soup())))


if __name__ == '__main__':
    main()
